import{_ as e,c as i,o as l,a}from"./app.d89524ac.js";const S=JSON.parse('{"title":"WEB 安全","description":"","frontmatter":{},"headers":[{"level":2,"title":"XSS","slug":"xss","link":"#xss","children":[{"level":3,"title":"防御方式","slug":"防御方式","link":"#防御方式","children":[]}]},{"level":2,"title":"CSRF","slug":"csrf","link":"#csrf","children":[{"level":3,"title":"防御方式","slug":"防御方式-1","link":"#防御方式-1","children":[]}]},{"level":2,"title":"点击劫持","slug":"点击劫持","link":"#点击劫持","children":[{"level":3,"title":"防御方式","slug":"防御方式-2","link":"#防御方式-2","children":[]}]},{"level":2,"title":"注入攻击","slug":"注入攻击","link":"#注入攻击","children":[{"level":3,"title":"防御方式","slug":"防御方式-3","link":"#防御方式-3","children":[]}]},{"level":2,"title":"文件上传漏洞","slug":"文件上传漏洞","link":"#文件上传漏洞","children":[{"level":3,"title":"防御方式","slug":"防御方式-4","link":"#防御方式-4","children":[]}]}],"relativePath":"other/web-security.md","lastUpdated":1673517898000}'),r={name:"other/web-security.md"},t=a('<h1 id="web-安全" tabindex="-1">WEB 安全 <a class="header-anchor" href="#web-安全" aria-hidden="true">#</a></h1><nav class="table-of-contents"><ul><li><a href="#xss">XSS</a><ul><li><a href="#防御方式">防御方式</a></li></ul></li><li><a href="#csrf">CSRF</a><ul><li><a href="#防御方式-1">防御方式</a></li></ul></li><li><a href="#点击劫持">点击劫持</a><ul><li><a href="#防御方式-2">防御方式</a></li></ul></li><li><a href="#注入攻击">注入攻击</a><ul><li><a href="#防御方式-3">防御方式</a></li></ul></li><li><a href="#文件上传漏洞">文件上传漏洞</a><ul><li><a href="#防御方式-4">防御方式</a></li></ul></li></ul></nav><h2 id="xss" tabindex="-1">XSS <a class="header-anchor" href="#xss" aria-hidden="true">#</a></h2><p>跨站脚本攻击，通常指黑客通过 HTML注入 篡改网页，插入恶意脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。</p><p>最常见的 XSS 攻击，就是通过读取浏览器的 cookie 对象，从而发起 cookie 劫持 攻击，以达到不用密码登录用户账户的目的。</p><p>其攻击的本质是 <strong>HTML注入</strong>，用户的数据被当成了 HTML 代码的一部分来执行，从而混淆了原有的语义，产生了新的语义。</p><h3 id="防御方式" tabindex="-1">防御方式 <a class="header-anchor" href="#防御方式" aria-hidden="true">#</a></h3><ol><li><p>HttpOnly：浏览器将禁止页面的 JavaScript 访问带有 HttpOnly 属性的 cookie</p><p>一个 cookie 的使用过程如下：</p><ol><li>浏览器向服务器发起请求，这时候没有 cookie</li><li>服务器返回时发送 Set-Cookie 头，向客户端浏览器写入 cookie</li><li>在该 cookie 到期前，浏览器访问该域下面的所有页面，都将发送该 cookie</li></ol></li><li><p>输入检查：常见的 web 漏洞如 XSS、SQL 注入等，都要求攻击者构造一些特殊字符，这些特殊字符可能是正常用户不会用到的，所以输入检查就有存在的必要了。客户端和服务端都需要进行输入检查——客户端节约服务器资源，服务端避免被攻击者绕过。可以使用成熟的 XSS Filter 库进行检查。</p></li><li><p>输出检查：一般来说，除了富文本的输出外，在变量输出到 HTML 页面时，可以使用<strong>编码</strong>或<strong>转义</strong>的方式来防御 XSS 攻击。</p></li></ol><h2 id="csrf" tabindex="-1">CSRF <a class="header-anchor" href="#csrf" aria-hidden="true">#</a></h2><p>跨站点请求伪造，指攻击者伪造用户请求执行某些操作以达到攻击目的。</p><p>CSRF 攻击的本质原因是，重要操作的所有参数都是可以被攻击者猜测到的。</p><h3 id="防御方式-1" tabindex="-1">防御方式 <a class="header-anchor" href="#防御方式-1" aria-hidden="true">#</a></h3><ol><li>验证码：CSRF 攻击的过程，往往是在用户不知情的情况下构造了网络请求，而验证码则强制用户必须与应用进行交互，才能完成最终请求。因此在通常情况下，验证码能够很好地遏制 CSRF 攻击。</li><li>Referer Check：常见于“防止图片盗链”，也可以被用来检查请求是否来自合法的“源”（Origin）。其缺陷在于，服务器并非什么时候都能获取到 Referer。</li><li>Anti CSRF Token：token 需要足够随机，并且需要同时放在表单和 session 中，提交时服务器验证二者是否一致来判断是否受到 CSRF 攻击。并且表单提交成功后，该 token 应该失效。</li></ol><h2 id="点击劫持" tabindex="-1">点击劫持 <a class="header-anchor" href="#点击劫持" aria-hidden="true">#</a></h2><p>点击劫持是一种视觉上的欺骗手段。攻击者使用一个透明的、不可见的 iframe，覆盖在一个网页上，然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的 iframe 页面。通过调整 iframe 页面的位置，可以诱使用户恰好点击在 iframe 页面的一些功能按钮上。</p><p>与 CSRF 不同的是，点击劫持利用的就是<strong>与用户产生交互的页面</strong>。</p><h3 id="防御方式-2" tabindex="-1">防御方式 <a class="header-anchor" href="#防御方式-2" aria-hidden="true">#</a></h3><p>针对传统的 ClickJacking ，一般是通过<strong>禁止跨域的 iframe</strong> 来防范。</p><ol><li>frame busting：通过写一段 JavaScript 代码，以禁止 iframe 的嵌套，但容易被绕过</li><li>X-Frame-Options：HTTP 头，当其值为 DENY 时，浏览器会拒绝当前页面加载任何 iframe 页面；其值为 SAMEORIGIN 时可加载同源域名下的页面；其值为 ALLOW-FROM origin 时，可定义允许加载 iframe 的地址。</li><li>其他：浏览器的“内容安全策略”（Content Security Policy）、安全插件/扩展等</li></ol><h2 id="注入攻击" tabindex="-1">注入攻击 <a class="header-anchor" href="#注入攻击" aria-hidden="true">#</a></h2><p>常见的有 SQL注入、CRLF注入、XML注入等。通常是应用违背了<strong>数据与代码分离原则</strong>导致的结果。</p><h3 id="防御方式-3" tabindex="-1">防御方式 <a class="header-anchor" href="#防御方式-3" aria-hidden="true">#</a></h3><ol><li>使用<strong>预编译语句</strong>，绑定变量</li><li>使用<strong>安全的</strong>存储过程，但要避免使用动态的 SQL 语句</li><li>检查数据类型</li><li>使用<strong>安全函数</strong></li></ol><h2 id="文件上传漏洞" tabindex="-1">文件上传漏洞 <a class="header-anchor" href="#文件上传漏洞" aria-hidden="true">#</a></h2><p>文件上传漏洞是指用户上传了一个可执行的脚本文件，并且通过此脚本文件获得了执行服务器端命令的能力。</p><h3 id="防御方式-4" tabindex="-1">防御方式 <a class="header-anchor" href="#防御方式-4" aria-hidden="true">#</a></h3><ol><li>文件上传的目录设置为<strong>不可执行</strong></li><li>判断文件类型：推荐使用白名单，结合使用 MIME type、后缀检查等方式，对文件类型进行判断；而对于图片的处理，可使用压缩函数或 resize 函数，在处理图片的同时破坏图片中可能包含的 HTML 代码</li><li>使用随机数改写文件名和文件路径：避免轻易被访问</li><li>单独设置文件服务器的域名：这里利用了浏览器的同源策略，可避免一些客户端攻击</li></ol>',27),n=[t];function s(o,h,d,c,p,f){return l(),i("div",null,n)}const g=e(r,[["render",s]]);export{S as __pageData,g as default};
