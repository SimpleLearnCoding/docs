import{_ as e,c as s,o as n,a as t}from"./app.0525e283.js";const m=JSON.parse('{"title":"ThinkPHP Issues","description":"","frontmatter":{},"headers":[{"level":2,"title":"消息队列","slug":"消息队列","link":"#消息队列","children":[{"level":3,"title":"两种执行方式的区别","slug":"两种执行方式的区别","link":"#两种执行方式的区别","children":[]}]}],"relativePath":"problem-and-solution/thinkphp-issues.md","lastUpdated":1675233411000}'),o={name:"problem-and-solution/thinkphp-issues.md"},a=t(`<h1 id="thinkphp-issues" tabindex="-1">ThinkPHP Issues <a class="header-anchor" href="#thinkphp-issues" aria-hidden="true">#</a></h1><blockquote><p>关于 ThinkPHP 框架的一些疑问。</p></blockquote><h2 id="消息队列" tabindex="-1">消息队列 <a class="header-anchor" href="#消息队列" aria-hidden="true">#</a></h2><p>官方扩展：<a href="https://github.com/top-think/think-queue" target="_blank" rel="noreferrer"><code>thinkphp/think-queue</code></a></p><p>执行命令如下：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki"><code><span class="line"><span style="color:#F8F8F2;">$ php think queue:listen</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F8F8F2;">$ php think queue:work --daemon（不加--daemon为执行单个任务）</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="两种执行方式的区别" tabindex="-1">两种执行方式的区别 <a class="header-anchor" href="#两种执行方式的区别" aria-hidden="true">#</a></h3><p>官方回答参见<a href="https://github.com/top-think/think-queue/issues/9#issuecomment-342800230" target="_blank" rel="noreferrer">#9</a>。总结如下：</p><ul><li>listen 模式负责管理 work 进程， work 进程则负责处理单个任务后退出；</li><li>work 进程退出后， listen 进程会再次创建一个新的 work 进程，来处理下一个任务；</li><li>work 进程超时后，listen 进程会及时结束 work 进程；</li><li>即 listen 进程是常驻的，每个 work 被创建时都会自动重新加载框架、加载最新代码；</li><li>而 work + daemon 模式下需要重启 work 进程方可加载最新代码。</li></ul><p>在使用<code>topthink/think-queue:3.0</code>版本（ThinkPHP 版本为 6.0）过程中，更推荐使用<code>php think queue:listen</code>模式。</p><h4 id="超时问题" tabindex="-1">超时问题？ <a class="header-anchor" href="#超时问题" aria-hidden="true">#</a></h4><p>使用过程中，遇到一个 job 由于执行时间过长，<code>php think queue:listen</code>命令抛出异常：</p><p><code>Symfony\\Component\\Process\\Exception\\ProcessTimedOutException：</code></p><p><code>The process &quot;&#39;/usr/local/bin/php&#39; &#39;think&#39; &#39;queue:work&#39; &#39;redis&#39; &#39;--once&#39; &#39;--queue=default&#39; &#39;--delay=0&#39; &#39;--memory=128&#39; &#39;--sleep=3&#39; &#39;--tries=0&#39;&quot; exceeded the timeout of 60 seconds.</code>。</p><p>一开始以为是 listen 命令需要设置监听时间，而监听时间默认为 60s，但没有找到相关配置；</p><p>后<strong>仔细查看</strong>异常信息，发现是 <strong>work 命令执行超时</strong>。</p><p>work 的默认执行超时时间是 60s（源代码位置：<code>\\think\\queue\\Worker::daemon</code>）。</p><p>从 issues 中我知道了可以<strong>通过给 listen 命令添加<code>--timeout</code>选项</strong>（help 手册无该选项）来避免超时问题。</p><p>但这样会导致如果后面有新的、<strong>执行时间更长的 job 加入时，listen 命令需要重启</strong>（因为参数需要变化）。</p>`,19),i=[a];function r(p,l,h,c,d,u){return n(),s("div",null,i)}const _=e(o,[["render",r]]);export{m as __pageData,_ as default};
